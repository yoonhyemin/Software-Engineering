#include<stdio.h>#include<stdlib.h>#include <math.h>int Save(FILE* outputfile, int geneID, int arrayID);void Load(FILE* file);char** Load2(FILE* file);void Free(void);static char* tabJump(char* s);static char* GetLine(FILE* inputfile);//여기까지가 헤더static char** _data = 0;static int* _rows = NULL;static int* _columns = NULL;int fileRow =100;int fileColumn = 0;void Load(FILE* file)/* Load in data from tab-delimited text file.* If an error occurs, an error message is returned.* If no error occurs, the string "ok" is returned.* In case of insufficient memory, NULL is returned.* All messages are allocated with malloc, and should be* freed by the calling routine. */{   char* line;   FILE* inputfile;   inputfile = file;   char* oneLine = NULL;   static char* matrix = NULL;      int n, i = 0, j = 0, count = 0;   const char* word;   while (1){      line = GetLine(file);       if (!line) { return NULL; }      if (line[0] == '\0')      {         free(line);         break;      }      else      {   fileColumn = 1;   for (oneLine = line; (*oneLine) != '\0'; oneLine++) if (*oneLine == '\t')  fileColumn++;     oneLine = tabJump(line);   free(line);   fileRow++;    }}   _rows = malloc((fileRow)* sizeof(int));         printf("f row%d, f cloumn %d\n", fileRow, fileColumn);   matrix = malloc(fileRow * sizeof(char*));   int row = 0;   /*   while (1)   {      line = GetLine(inputfile);      printf("왜안되냐%s\n", line);      if (!line) { return NULL; }      if (line[0] == '\0')      {         free(line);         break;      }      else      {         //line 에 글자가 있는경우         int column = 0;         column = 0;         fileColumn = 0;         oneLine = line;           while (oneLine) {            char* token = oneLine;            oneLine = tabJump(oneLine);            char* error = NULL;            matrix[row][column] = 0;            if (token != '\0')            {               if (!(*error)) matrix[row][column] = word;            }            column++;            fileColumn++;         }         row++;      }      free(line);   }   if (inputfile == NULL)   {      printf("파일열기 실패 원본파일이 없습니다.\n");      exit(0);   }   */   fclose(inputfile);   }char** Load2(FILE* file)/* Load in data from tab-delimited text file.* If an error occurs, an error message is returned.* If no error occurs, the string "ok" is returned.* In case of insufficient memory, NULL is returned.* All messages are allocated with malloc, and should be* freed by the calling routine. */{   char* line;   FILE* inputfile;   inputfile = file;   char* oneLine = NULL;   static char** matrix = 0;   int n, i = 0, j = 0, count = 0;   const char* word;   /*while (1){      line = GetLine(file);      if (!line) { return NULL; }      if (line[0] == '\0')      {         free(line);         break;      }      else      {         fileColumn = 1;         for (oneLine = line; (*oneLine) != '\0'; oneLine++) if (*oneLine == '\t')  fileColumn++;         oneLine = tabJump(line);         free(line);         fileRow++;      }   }   _rows = malloc((fileRow)* sizeof(int));   _columns = malloc((fileColumn)* sizeof(int));   _rows = fileRow;   _columns = fileColumn;   printf("f row%d, f cloumn %d\n", fileRow, fileColumn);   */      int row = 0;   matrix = malloc(fileRow * sizeof(char));   if (matrix == NULL) return NULL; // Not enough memory available       matrix[0] = 0;   while (1)   {      line = GetLine(inputfile);      printf("%s\n", line);      if (!line) { return NULL; }      if (line[0] == '\0')      {         free(line);         break;      }      else      {         //line 에 글자가 있는경우         oneLine = line;         while (oneLine) {            char* token = oneLine;            oneLine = tabJump(oneLine);            char* error = NULL;            matrix[row] = 0;            if (token != '\0')            {               matrix[row] = token;               printf("matrix[%d] = %s\n", row,matrix[row]);               row++;            }         }      }      free(line);   }   if (inputfile == NULL)   {      printf("파일열기 실패 원본파일이 없습니다.\n");      exit(0);   }   fclose(inputfile);   return matrix;}static char* GetLine(FILE* inputfile)/* The function GetLine reads one line from the inputfile, and returns it as a* null-terminated string. If inputfile is at EOF, an empty string is returned.* Empty lines are skipped.* If this function fails due to memory allocation error, it returns NULL.* The calling routine should free the char* returned by GetLine.*/{   char character;   int n = 0;   int size = 1023;   char* temp;   char* line = malloc((size + 1) * sizeof(char));   if (!line) return NULL;   while (n == 0)   {      while ((character = getc(inputfile)) != EOF && character != '\r' && character != '\n')      {         if (n == size)         {            size *= 2;            temp = realloc(line, (size + 1) * sizeof(char));            if (!temp)            {               free(line);               return NULL;            }            line = temp;         }         line[n] = (char)character;         n++;      }      if (character == '\r')      {         character = getc(inputfile);         if (character != '\n' && character != EOF) ungetc(character, inputfile);      }      if (character == EOF) break;   }   line[n] = '\0';   temp = realloc(line, (n + 1) * sizeof(char));   if (!temp)      /* This should not happen, as temp is smaller than line.      * But let's check to make sure anyway. */   {      free(line);      return NULL;   }   return temp;}static char* tabJump(char* s){   char* p = s;   while (1)   {      if (*p == '\0') return NULL;      if (*p == '\t')      {         *p = '\0';         return p + 1;      }      p++;   }   /* Never get here */   return NULL;}// geneID나 arrayID부분은 노트나 수첩으로 바꾸면 될듯합니다..int Save(FILE* outputfile, int geneID, int arrayID){   int row, column;   if (geneID) fputs("GID\t", outputfile);   //fputs(_uniqID, outputfile);   fputs("\tNAME\tGWEIGHT", outputfile);   /* Now add headers for data columns */   for (column = 0; column < _columns; column++)   {      putc('\t', outputfile);      //   fputs(_arrayname[_arrayindex[column]], outputfile);   }   putc('\n', outputfile);      if (geneID) fputs("AID", outputfile);   /* Now add headers for data columns */   for (column = 0; column < _columns; column++)   {      putc('\t', outputfile);      //   fputs(_arrayname[_arrayindex[column]], outputfile);   }   putc('\n', outputfile);   return 1;}int main() {   //file관련 선언들   FILE* inputfile;   inputfile = fopen("ggggg.txt", "rt");   FILE* output;   //이 아래 7줄은 무시해도 됌.   char* jobname = "";   const char* basename = "note"; //저장하고싶은 이름 3중 하나 골라서하세요   int n = strlen(basename);   int ne = strlen(basename) + strlen(".ext") + 1;   char* const filename = malloc(ne * sizeof(char));   jobname = malloc((n + 1) * sizeof(char));   strncpy(jobname, basename, n);   jobname[n] = '\0';   // 자주 쓰는 변수들 선언과, file row 와 column을 나타내는 변수들   int i, j;   int nn = fileRow;   int aa;   int r, t;   char* ok;   int row;   // pmlcluster, treesort등에 들어갈 변수들, cluster.c에서 긁은것들   _data = malloc(fileRow * sizeof(char));   if (_data == NULL) return NULL; // Not enough memory available    _data[0] = 0;   //Load(inputfile);   _data = Load2(inputfile);   printf("%s\n", _data);   //이제 _data matrix에 파일의 값이 들어갈것임..}
